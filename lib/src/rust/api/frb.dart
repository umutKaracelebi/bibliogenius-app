// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'frb.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `db`, `install_panic_hook`, `runtime`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`, `from`, `from`

/// Initialize the FFI backend with database at the given path
/// Must be called before any other FFI functions
Future<String> initBackend({required String dbPath}) =>
    RustLib.instance.api.crateApiFrbInitBackend(dbPath: dbPath);

/// Check if the FFI backend is healthy
String healthCheck() => RustLib.instance.api.crateApiFrbHealthCheck();

/// Get the FFI backend version
String getVersion() => RustLib.instance.api.crateApiFrbGetVersion();

/// Simple greeting function to test the bridge
String greet({required String name}) =>
    RustLib.instance.api.crateApiFrbGreet(name: name);

/// Check if mDNS discovery service is currently active
/// This is a sync function that can be called to check status
bool isMdnsAvailable() => RustLib.instance.api.crateApiFrbIsMdnsAvailable();

/// Get the mDNS service type used for discovery
String getMdnsServiceType() =>
    RustLib.instance.api.crateApiFrbGetMdnsServiceType();

/// Get locally discovered peers via mDNS
/// This returns peers that have been found on the local network
Future<List<FrbDiscoveredPeer>> getLocalPeersFfi() =>
    RustLib.instance.api.crateApiFrbGetLocalPeersFfi();

/// Initialize mDNS service for discovery
/// Must be called to start announcing and discovering peers
Future<String> initMdnsFfi({
  required String libraryName,
  required int port,
  String? libraryId,
}) => RustLib.instance.api.crateApiFrbInitMdnsFfi(
  libraryName: libraryName,
  port: port,
  libraryId: libraryId,
);

/// Stop mDNS service
Future<String> stopMdnsFfi() => RustLib.instance.api.crateApiFrbStopMdnsFfi();

/// Create a new book
Future<FrbBook> createBook({required FrbBook book}) =>
    RustLib.instance.api.crateApiFrbCreateBook(book: book);

/// Get all books with optional filters
Future<List<FrbBook>> getAllBooks({
  String? status,
  String? title,
  String? tag,
}) => RustLib.instance.api.crateApiFrbGetAllBooks(
  status: status,
  title: title,
  tag: tag,
);

/// Get a single book by ID
Future<FrbBook> getBookById({required int id}) =>
    RustLib.instance.api.crateApiFrbGetBookById(id: id);

/// Update an existing book
Future<FrbBook> updateBook({required int id, required FrbBook book}) =>
    RustLib.instance.api.crateApiFrbUpdateBook(id: id, book: book);

/// Delete a book
Future<void> deleteBook({required int id}) =>
    RustLib.instance.api.crateApiFrbDeleteBook(id: id);

/// Count total books
Future<PlatformInt64> countBooks() =>
    RustLib.instance.api.crateApiFrbCountBooks();

/// Enrich books that have an ISBN but no cover by checking external sources.
/// Runs in background, returns the count of covers found and persisted.
Future<int> enrichMissingCovers() =>
    RustLib.instance.api.crateApiFrbEnrichMissingCovers();

/// Search for a cover URL for a single ISBN from external sources.
Future<String?> searchCoverForBook({required String isbn}) =>
    RustLib.instance.api.crateApiFrbSearchCoverForBook(isbn: isbn);

/// Search for a cover URL by title with author verification.
/// Used as a fallback when ISBN-based search returns nothing.
/// Returns a cover only if the result author matches the given author.
Future<String?> searchCoverByTitle({
  required String title,
  String? author,
  bool? enableGoogle,
}) => RustLib.instance.api.crateApiFrbSearchCoverByTitle(
  title: title,
  author: author,
  enableGoogle: enableGoogle,
);

/// Search ALL enabled cover sources in parallel for a given ISBN.
/// Returns all found cover candidates for the picker carousel.
Future<List<FrbCoverCandidate>> searchAllCoversForBook({
  required String isbn,
}) => RustLib.instance.api.crateApiFrbSearchAllCoversForBook(isbn: isbn);

/// Search ALL enabled sources by title in parallel for the cover picker.
Future<List<FrbCoverCandidate>> searchAllCoversByTitle({
  required String title,
  String? author,
  bool? enableGoogle,
}) => RustLib.instance.api.crateApiFrbSearchAllCoversByTitle(
  title: title,
  author: author,
  enableGoogle: enableGoogle,
);

/// Look up book metadata by ISBN from external sources (BNF, Inventaire, OpenLibrary, etc.).
/// Used by the metadata refresh feature to let users preview and cherry-pick fields.
Future<FrbBookMetadata?> lookupBookMetadata({
  required String isbn,
  String? lang,
}) =>
    RustLib.instance.api.crateApiFrbLookupBookMetadata(isbn: isbn, lang: lang);

/// Get all tags with hierarchy info
Future<List<FrbTag>> getAllTags() =>
    RustLib.instance.api.crateApiFrbGetAllTags();

/// Create a new tag
Future<FrbTag> createTag({required String name, int? parentId}) =>
    RustLib.instance.api.crateApiFrbCreateTag(name: name, parentId: parentId);

/// Update a tag
Future<FrbTag> updateTag({
  required int id,
  required String name,
  int? parentId,
}) => RustLib.instance.api.crateApiFrbUpdateTag(
  id: id,
  name: name,
  parentId: parentId,
);

/// Delete a tag
Future<void> deleteTag({required int id}) =>
    RustLib.instance.api.crateApiFrbDeleteTag(id: id);

/// Reorder books by updating shelf positions
Future<void> reorderBooks({required List<int> bookIds}) =>
    RustLib.instance.api.crateApiFrbReorderBooks(bookIds: bookIds);

/// Get all contacts with optional filters
Future<List<FrbContact>> getAllContacts({
  int? libraryId,
  String? contactType,
}) => RustLib.instance.api.crateApiFrbGetAllContacts(
  libraryId: libraryId,
  contactType: contactType,
);

/// Get a single contact by ID
Future<FrbContact> getContactById({required int id}) =>
    RustLib.instance.api.crateApiFrbGetContactById(id: id);

/// Count total contacts
Future<PlatformInt64> countContacts() =>
    RustLib.instance.api.crateApiFrbCountContacts();

/// Create a new contact
Future<FrbContact> createContact({required FrbContact contact}) =>
    RustLib.instance.api.crateApiFrbCreateContact(contact: contact);

/// Update an existing contact
Future<FrbContact> updateContact({required FrbContact contact}) =>
    RustLib.instance.api.crateApiFrbUpdateContact(contact: contact);

/// Delete a contact by ID (soft delete)
Future<void> deleteContact({required int id}) =>
    RustLib.instance.api.crateApiFrbDeleteContact(id: id);

/// Get all loans with optional filters
Future<List<FrbLoan>> getAllLoans({
  int? libraryId,
  String? status,
  int? contactId,
}) => RustLib.instance.api.crateApiFrbGetAllLoans(
  libraryId: libraryId,
  status: status,
  contactId: contactId,
);

/// Count active loans
Future<PlatformInt64> countActiveLoans() =>
    RustLib.instance.api.crateApiFrbCountActiveLoans();

/// Create a new loan
Future<int> createLoan({
  required int copyId,
  required int contactId,
  required int libraryId,
  required String loanDate,
  required String dueDate,
  String? notes,
}) => RustLib.instance.api.crateApiFrbCreateLoan(
  copyId: copyId,
  contactId: contactId,
  libraryId: libraryId,
  loanDate: loanDate,
  dueDate: dueDate,
  notes: notes,
);

/// Return a loan
Future<String> returnLoan({required int id}) =>
    RustLib.instance.api.crateApiFrbReturnLoan(id: id);

/// Reset the entire application - deletes all data from all tables
/// This is irreversible and should be used with caution
Future<String> resetApp() => RustLib.instance.api.crateApiFrbResetApp();

/// Start the HTTP server on the specified port (FFI)
/// This is required for P2P functionality in standalone mode
/// If the specified port is occupied, tries the next 10 ports automatically
Future<int> startServer({required int port}) =>
    RustLib.instance.api.crateApiFrbStartServer(port: port);

/// Simplified book structure for FFI
@freezed
sealed class FrbBook with _$FrbBook {
  const factory FrbBook({
    int? id,
    required String title,
    String? author,
    String? isbn,
    String? summary,
    String? publisher,
    int? publicationYear,
    String? coverUrl,
    String? largeCoverUrl,
    String? readingStatus,
    int? shelfPosition,
    int? userRating,
    String? subjects,
    String? createdAt,
    String? updatedAt,
    String? finishedReadingAt,
    String? startedReadingAt,
    required bool owned,
    double? price,
    List<String>? digitalFormats,
  }) = _FrbBook;
}

/// Metadata fetched from external sources for a book refresh.
/// Each field is optional â€” only non-null fields have data from the source.
@freezed
sealed class FrbBookMetadata with _$FrbBookMetadata {
  const factory FrbBookMetadata({
    String? title,
    String? author,
    String? publisher,
    String? publicationYear,
    String? coverUrl,
    String? summary,
  }) = _FrbBookMetadata;
}

/// Simplified contact structure for FFI
@freezed
sealed class FrbContact with _$FrbContact {
  const factory FrbContact({
    int? id,
    required String contactType,
    required String name,
    String? firstName,
    String? email,
    String? phone,
    String? address,
    String? streetAddress,
    String? postalCode,
    String? city,
    String? country,
    double? latitude,
    double? longitude,
    String? notes,
    int? userId,
    int? libraryOwnerId,
    required bool isActive,
  }) = _FrbContact;
}

/// A cover candidate from an external source, for the multi-cover picker.
@freezed
sealed class FrbCoverCandidate with _$FrbCoverCandidate {
  const factory FrbCoverCandidate({
    required String url,
    required String source,
  }) = _FrbCoverCandidate;
}

/// Discovered peer on local network (FFI-compatible)
@freezed
sealed class FrbDiscoveredPeer with _$FrbDiscoveredPeer {
  const factory FrbDiscoveredPeer({
    required String name,
    required String host,
    required int port,
    required List<String> addresses,
    String? libraryId,
    required String discoveredAt,
  }) = _FrbDiscoveredPeer;
}

/// Simplified loan structure for FFI
@freezed
sealed class FrbLoan with _$FrbLoan {
  const factory FrbLoan({
    required int id,
    required int copyId,
    required int contactId,
    required int libraryId,
    required String loanDate,
    required String dueDate,
    String? returnDate,
    required String status,
    String? notes,
    required String contactName,
    required String bookTitle,
  }) = _FrbLoan;
}

/// Simplified tag structure for FFI
@freezed
sealed class FrbTag with _$FrbTag {
  const factory FrbTag({
    required int id,
    required String name,
    int? parentId,
    required PlatformInt64 count,
  }) = _FrbTag;
}
